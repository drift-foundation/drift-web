module web.jwt.claims

import std.core as core;
import std.json as json;
import web.jwt.errors as errors;
import web.jwt.model as model;

export {
	validate_temporal_claims
};

fn _check_numeric_claim(node: &json.JsonNode, key: &String) nothrow -> core.Result<Optional<Int>, errors.JwtError> {
	match node.get(key) {
		Optional::None => { return core.Result::Ok(Optional<Int>::None()); },
		Optional::Some(claim_node) => {
			match claim_node.as_int() {
				Optional::Some(v) => { return core.Result::Ok(Optional::Some(v)); },
				Optional::None => {
					return core.Result::Err(errors.jwt_error(errors.TAG_CLAIM_INVALID_TYPE, "claim " + *key + " must be numeric"));
				}
			}
		}
	}
}

// Clamp a timestamp to a safe range to prevent overflow in arithmetic.
// Any legitimate JWT timestamp falls within year 0001..9999 CE.
// With all operands clamped, the maximum difference between any two values
// is ~315 billion, which fits safely in a 64-bit signed Int even after adding
// policy offsets (skew_sec, max_future_iat_sec).
const SAFE_TS_MIN: Int = -62135596800;
const SAFE_TS_MAX: Int = 253402300800;

fn _safe_ts(value: Int) nothrow -> Int {
	if value < SAFE_TS_MIN { return SAFE_TS_MIN; }
	if value > SAFE_TS_MAX { return SAFE_TS_MAX; }
	return value;
}

pub fn validate_temporal_claims(payload_node: &json.JsonNode, now_unix: Int, policy: &model.JwtVerifyPolicy) nothrow -> core.Result<Void, errors.JwtError> {
	val now = _safe_ts(now_unix);
	val exp_key = "exp";
	match _check_numeric_claim(payload_node, &exp_key) {
		core.Result::Err(e) => { return core.Result::Err(e); },
		core.Result::Ok(opt) => {
			match opt {
				Optional::Some(raw_exp) => {
					val exp = _safe_ts(raw_exp);
					if now - policy.skew_sec > exp {
						return core.Result::Err(errors.jwt_error(errors.TAG_EXPIRED, "token expired"));
					}
				},
				Optional::None => {}
			}
		}
	}
	val nbf_key = "nbf";
	match _check_numeric_claim(payload_node, &nbf_key) {
		core.Result::Err(e) => { return core.Result::Err(e); },
		core.Result::Ok(opt) => {
			match opt {
				Optional::Some(raw_nbf) => {
					val nbf = _safe_ts(raw_nbf);
					if nbf - policy.skew_sec > now {
						return core.Result::Err(errors.jwt_error(errors.TAG_NOT_BEFORE, "token not yet valid"));
					}
				},
				Optional::None => {}
			}
		}
	}
	val iat_key = "iat";
	match _check_numeric_claim(payload_node, &iat_key) {
		core.Result::Err(e) => { return core.Result::Err(e); },
		core.Result::Ok(opt) => {
			match opt {
				Optional::Some(raw_iat) => {
					val iat = _safe_ts(raw_iat);
					if iat - now > policy.max_future_iat_sec {
						return core.Result::Err(errors.jwt_error(errors.TAG_ISSUED_AT_FUTURE, "iat is too far in the future"));
					}
				},
				Optional::None => {}
			}
		}
	}
	return core.Result::Ok(core.void_value());
}
