module web.jwt.signing

import std.core as core;
import std.io as io;
import std.codec as codec;
import std.crypto as crypto;
import std.json as json;
import web.jwt.errors as errors;
import web.jwt.model as model;

export {
	sign_hs256_impl
};

fn _string_bytes(s: &String) nothrow -> Array<Byte> {
	var out: Array<Byte> = [];
	var i = 0;
	val n = s.byte_length();
	while i < n {
		out.push(core.string_byte_at(s, i));
		i = i + 1;
	}
	return move out;
}

fn _dup_string(s: &String) nothrow -> String {
	val n = s.byte_length();
	var b = io.buffer(n);
	var i = 0;
	while i < n {
		io.buffer_write(&mut b, i, core.string_byte_at(s, i));
		i = i + 1;
	}
	return core.string_from_utf8_bytes(io.buffer_ptr(&b), n);
}

fn _validate_header(header_json: &String, opts: &model.SignOptions) nothrow -> core.Result<Void, errors.JwtError> {
	var header_node = json.JsonNode::Null();
	match json.parse(header_json) {
		core.Result::Ok(v) => { header_node = move v; },
		core.Result::Err(_) => { return core.Result::Err(errors.jwt_error(errors.TAG_INVALID_HEADER_JSON, "header is not valid JSON")); }
	}
	val alg_key = "alg";
	match header_node.get(&alg_key) {
		Optional::None => { return core.Result::Err(errors.jwt_error(errors.TAG_MISSING_ALG, "header missing alg field")); },
		Optional::Some(alg_node) => {
			match alg_node.as_string() {
				Optional::None => { return core.Result::Err(errors.jwt_error(errors.TAG_UNSUPPORTED_ALG, "alg is not a string")); },
				Optional::Some(alg_str) => {
					if alg_str != "HS256" {
						return core.Result::Err(errors.jwt_error(errors.TAG_UNSUPPORTED_ALG, "unsupported alg: " + _dup_string(&alg_str)));
					}
				}
			}
		}
	}
	if opts.enforce_typ_jwt {
		val typ_key = "typ";
		match header_node.get(&typ_key) {
			Optional::None => { return core.Result::Err(errors.jwt_error(errors.TAG_HEADER_TYP_MISMATCH, "header missing typ field")); },
			Optional::Some(typ_node) => {
				match typ_node.as_string() {
					Optional::None => { return core.Result::Err(errors.jwt_error(errors.TAG_HEADER_TYP_MISMATCH, "typ is not a string")); },
					Optional::Some(typ_str) => {
						if typ_str != "JWT" {
							return core.Result::Err(errors.jwt_error(errors.TAG_HEADER_TYP_MISMATCH, "typ must be JWT"));
						}
					}
				}
			}
		}
	}
	return core.Result::Ok(core.void_value());
}

pub fn sign_hs256_impl(header_json: &String, payload_json: &String, secret: &Array<Byte>, opts: &model.SignOptions) nothrow -> core.Result<String, errors.JwtError> {
	match _validate_header(header_json, opts) {
		core.Result::Ok(_) => {},
		core.Result::Err(e) => { return core.Result::Err(e); }
	}
	val header_bytes = _string_bytes(header_json);
	val payload_bytes = _string_bytes(payload_json);
	val segment0 = codec.base64url_encode(&header_bytes);
	val segment1 = codec.base64url_encode(&payload_bytes);
	val signing_input = segment0 + "." + segment1;
	val signing_input_bytes = _string_bytes(&signing_input);
	val signature = crypto.hmac_sha256(secret, &signing_input_bytes);
	val segment2 = codec.base64url_encode(&signature);
	return core.Result::Ok(signing_input + "." + segment2);
}
