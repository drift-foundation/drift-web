module web.rest.tests.unit.jwt_guard_test

import std.core as core;
import std.json as json;
import web.jwt as jwt;
import web.rest as rest;

// Story 2: GET /v1/me — JWT guard unauthorized/authorized flows.
// Tests JWT middleware mapping from jwt.JwtError.tag to RestError event/tag/status.
// Guard now uses RestGuard-compatible contract: (config, req, ctx).
// Token is extracted from Authorization: Bearer <token> header on Request.

fn _test_secret() nothrow -> Array<Byte> {
	var s: Array<Byte> = [];
	s.push(cast<Byte>(115)); // s
	s.push(cast<Byte>(51));  // 3
	s.push(cast<Byte>(99));  // c
	s.push(cast<Byte>(114)); // r
	s.push(cast<Byte>(51));  // 3
	s.push(cast<Byte>(116)); // t
	return move s;
}

fn _wrong_secret() nothrow -> Array<Byte> {
	var s: Array<Byte> = [];
	s.push(cast<Byte>(119)); // w
	s.push(cast<Byte>(114)); // r
	s.push(cast<Byte>(111)); // o
	s.push(cast<Byte>(110)); // n
	s.push(cast<Byte>(103)); // g
	return move s;
}

fn _default_policy() nothrow -> jwt.JwtVerifyPolicy {
	var pb = jwt.new_verify_policy_builder();
	pb.require_typ_jwt = true;
	match jwt.build_verify_policy(move pb) {
		core.Result::Ok(v) => { return v; },
		core.Result::Err(_) => {
			return jwt.JwtVerifyPolicy(skew_sec = 0, max_future_iat_sec = 0, require_typ_jwt = true);
		}
	}
}

fn _default_config() nothrow -> rest.JwtGuardConfig {
	return rest.new_jwt_guard_config(_test_secret(), _default_policy());
}

fn _sign_token(payload: &String) nothrow -> core.Result<String, jwt.JwtError> {
	val header = "{\"alg\":\"HS256\",\"typ\":\"JWT\"}";
	var secret = _test_secret();
	var opts = jwt.new_sign_options();
	return jwt.sign_hs256(&header, payload, &secret, &opts);
}

fn _valid_token() nothrow -> core.Result<String, jwt.JwtError> {
	val payload = "{\"sub\":\"user-42\"}";
	return _sign_token(&payload);
}

fn _bearer_request(token: &String) nothrow -> rest.Request {
	var req = rest.new_request("GET", "/v1/me");
	rest.add_header(&mut req, "Authorization", "Bearer " + *token);
	return move req;
}

// --- Scenario: missing Authorization header → 401 unauthorized ---

fn scenario_missing_authorization() nothrow -> Int {
	val config = _default_config();
	val req = rest.new_request("GET", "/v1/me");
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 1301; },
		core.Result::Err(e) => {
			if e.status != 401 { return 1302; }
			if e.event != "unauthorized" { return 1303; }
			if e.tag != "missing-authorization" { return 1304; }
			return 0;
		}
	}
}

// --- Scenario: invalid Authorization format (not Bearer) → 400 request-invalid ---

fn scenario_invalid_authorization_format() nothrow -> Int {
	val config = _default_config();
	var req = rest.new_request("GET", "/v1/me");
	rest.add_header(&mut req, "Authorization", "Basic dXNlcjpwYXNz");
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 1401; },
		core.Result::Err(e) => {
			if e.status != 400 { return 1402; }
			if e.event != "request-invalid" { return 1403; }
			if e.tag != "invalid-authorization-format" { return 1404; }
			return 0;
		}
	}
}

// --- Scenario: valid token → guard passes, principal extracted ---

fn scenario_valid_token_authorized() nothrow -> Int {
	var token = "";
	match _valid_token() {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 101; }
	}
	val config = _default_config();
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => {},
		core.Result::Err(_) => { return 102; }
	}
	match rest.get_principal(&ctx) {
		Optional::None => { return 103; },
		Optional::Some(p) => {
			if p.sub != "user-42" { return 104; }
			return 0;
		}
	}
}

// --- Scenario: valid token → handler returns 200 with sub ---

fn scenario_me_handler_success() nothrow -> Int {
	var token = "";
	match _valid_token() {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 201; }
	}
	val config = _default_config();
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => {},
		core.Result::Err(_) => { return 202; }
	}
	match rest.require_principal(&ctx) {
		core.Result::Err(_) => { return 203; },
		core.Result::Ok(p) => {
			val resp = rest.json_response(200, "{\"sub\":\"" + p.sub + "\"}");
			if resp.status != 200 { return 204; }
			if resp.body != "{\"sub\":\"user-42\"}" { return 205; }
			return 0;
		}
	}
}

// --- Scenario: no principal in context → require_principal fails ---

fn scenario_no_principal_unauthorized() nothrow -> Int {
	val ctx = rest.new_context();
	match rest.require_principal(&ctx) {
		core.Result::Ok(_) => { return 301; },
		core.Result::Err(e) => {
			if e.status != 401 { return 302; }
			if e.event != "unauthorized" { return 303; }
			if e.tag != "missing-principal" { return 304; }
			return 0;
		}
	}
}

// --- Scenario: expired token → 401 unauthorized, tag=jwt-expired ---

fn scenario_expired_token_unauthorized() nothrow -> Int {
	val payload = "{\"sub\":\"u1\",\"exp\":1700000000}";
	var token = "";
	match _sign_token(&payload) {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 401; }
	}
	var config = _default_config();
	config.now_unix = 1700099000;
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 402; },
		core.Result::Err(e) => {
			if e.status != 401 { return 403; }
			if e.event != "unauthorized" { return 404; }
			if e.tag != "jwt-expired" { return 405; }
			return 0;
		}
	}
}

// --- Scenario: signature mismatch → 401 unauthorized ---

fn scenario_signature_mismatch_unauthorized() nothrow -> Int {
	var token = "";
	match _valid_token() {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 501; }
	}
	val config = rest.new_jwt_guard_config(_wrong_secret(), _default_policy());
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 502; },
		core.Result::Err(e) => {
			if e.status != 401 { return 503; }
			if e.event != "unauthorized" { return 504; }
			if e.tag != "jwt-signature-mismatch" { return 505; }
			return 0;
		}
	}
}

// --- Scenario: not-before → 401 unauthorized ---

fn scenario_not_before_unauthorized() nothrow -> Int {
	val payload = "{\"sub\":\"u1\",\"nbf\":1700000100}";
	var token = "";
	match _sign_token(&payload) {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 601; }
	}
	var config = _default_config();
	config.now_unix = 1700000000;
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 602; },
		core.Result::Err(e) => {
			if e.status != 401 { return 603; }
			if e.event != "unauthorized" { return 604; }
			if e.tag != "jwt-not-before" { return 605; }
			return 0;
		}
	}
}

// --- Scenario: iat-future → 401 unauthorized ---

fn scenario_iat_future_unauthorized() nothrow -> Int {
	val payload = "{\"sub\":\"u1\",\"iat\":1700001000}";
	var token = "";
	match _sign_token(&payload) {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 701; }
	}
	var config = _default_config();
	config.now_unix = 1700000000;
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 702; },
		core.Result::Err(e) => {
			if e.status != 401 { return 703; }
			if e.event != "unauthorized" { return 704; }
			if e.tag != "jwt-issued-at-future" { return 705; }
			return 0;
		}
	}
}

// --- Scenario: invalid format (no dots) → 400 request-invalid ---

fn scenario_invalid_format_bad_request() nothrow -> Int {
	val config = _default_config();
	var req = rest.new_request("GET", "/v1/me");
	rest.add_header(&mut req, "Authorization", "Bearer not-a-jwt");
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 801; },
		core.Result::Err(e) => {
			if e.status != 400 { return 802; }
			if e.event != "request-invalid" { return 803; }
			if e.tag != "jwt-invalid-format" { return 804; }
			return 0;
		}
	}
}

// --- Scenario: invalid segment (bad base64url) → 400 request-invalid ---

fn scenario_invalid_segment_bad_request() nothrow -> Int {
	val config = _default_config();
	var req = rest.new_request("GET", "/v1/me");
	rest.add_header(&mut req, "Authorization", "Bearer ====.====.====");
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 901; },
		core.Result::Err(e) => {
			if e.status != 400 { return 902; }
			if e.event != "request-invalid" { return 903; }
			if e.tag != "jwt-invalid-segment" { return 904; }
			return 0;
		}
	}
}

// --- Scenario: unsupported alg → 400 request-invalid ---

fn scenario_unsupported_alg_bad_request() nothrow -> Int {
	val header = "{\"alg\":\"none\",\"typ\":\"JWT\"}";
	val payload = "{\"sub\":\"u1\"}";
	var secret = _test_secret();
	var opts = jwt.new_sign_options();
	match jwt.sign_hs256(&header, &payload, &secret, &opts) {
		core.Result::Ok(_) => { return 1001; },
		core.Result::Err(e) => {
			if e.tag != "jwt-unsupported-alg" { return 1002; }
		}
	}
	return 0;
}

// --- Scenario: error envelope renders correct JSON for unauthorized ---

fn scenario_error_envelope_unauthorized() nothrow -> Int {
	val err = rest.rest_error(401, "unauthorized", "jwt-expired", "token expired");
	val event_id = "evt-test-001";
	val resp = rest.error_envelope(&err, &event_id);
	if resp.status != 401 { return 1101; }
	match json.parse(&resp.body) {
		core.Result::Err(_) => { return 1102; },
		core.Result::Ok(node) => {
			val event_key = "event";
			match node.get(&event_key) {
				Optional::None => { return 1103; },
				Optional::Some(ev) => {
					match ev.as_string() {
						Optional::None => { return 1104; },
						Optional::Some(v) => {
							if v != "unauthorized" { return 1105; }
						}
					}
				}
			}
			val tag_key = "tag";
			match node.get(&tag_key) {
				Optional::None => { return 1106; },
				Optional::Some(tg) => {
					match tg.as_string() {
						Optional::None => { return 1107; },
						Optional::Some(v) => {
							if v != "jwt-expired" { return 1108; }
						}
					}
				}
			}
			val eid_key = "event_id";
			match node.get(&eid_key) {
				Optional::None => { return 1109; },
				Optional::Some(eid) => {
					match eid.as_string() {
						Optional::None => { return 1110; },
						Optional::Some(v) => {
							if v != "evt-test-001" { return 1111; }
						}
					}
				}
			}
			val fields_key = "fields";
			match node.get(&fields_key) {
				Optional::None => { return 1112; },
				Optional::Some(_) => {
					return 0;
				}
			}
		}
	}
}

// --- Scenario: typ mismatch → 400 request-invalid ---

fn scenario_typ_mismatch_bad_request() nothrow -> Int {
	val header = "{\"alg\":\"HS256\",\"typ\":\"JWE\"}";
	val payload = "{\"sub\":\"u1\"}";
	var secret = _test_secret();
	var opts = jwt.new_sign_options();
	opts.enforce_typ_jwt = false;
	var token = "";
	match jwt.sign_hs256(&header, &payload, &secret, &opts) {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 1201; }
	}
	val config = rest.new_jwt_guard_config(_test_secret(), _default_policy());
	val req = _bearer_request(&token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => { return 1202; },
		core.Result::Err(e) => {
			if e.status != 400 { return 1203; }
			if e.event != "request-invalid" { return 1204; }
			if e.tag != "jwt-header-typ-mismatch" { return 1205; }
			return 0;
		}
	}
}

// --- Scenario: lowercase "authorization" header → guard still works (RFC 7230) ---

fn scenario_lowercase_authorization_header() nothrow -> Int {
	var token = "";
	match _valid_token() {
		core.Result::Ok(v) => { token = move v; },
		core.Result::Err(_) => { return 1501; }
	}
	val config = _default_config();
	var req = rest.new_request("GET", "/v1/me");
	rest.add_header(&mut req, "authorization", "Bearer " + token);
	var ctx = rest.new_context();
	match rest.jwt_guard_apply(&config, &req, &mut ctx) {
		core.Result::Ok(_) => {},
		core.Result::Err(_) => { return 1502; }
	}
	match rest.get_principal(&ctx) {
		Optional::None => { return 1503; },
		Optional::Some(p) => {
			if p.sub != "user-42" { return 1504; }
		}
	}
	return 0;
}

fn main() nothrow -> Int {
	val ma = scenario_missing_authorization();
	if ma != 0 { return ma; }
	val ia = scenario_invalid_authorization_format();
	if ia != 0 { return ia; }
	val a = scenario_valid_token_authorized();
	if a != 0 { return a; }
	val b = scenario_me_handler_success();
	if b != 0 { return b; }
	val c = scenario_no_principal_unauthorized();
	if c != 0 { return c; }
	val d = scenario_expired_token_unauthorized();
	if d != 0 { return d; }
	val e = scenario_signature_mismatch_unauthorized();
	if e != 0 { return e; }
	val f = scenario_not_before_unauthorized();
	if f != 0 { return f; }
	val g = scenario_iat_future_unauthorized();
	if g != 0 { return g; }
	val h = scenario_invalid_format_bad_request();
	if h != 0 { return h; }
	val i = scenario_invalid_segment_bad_request();
	if i != 0 { return i; }
	val j = scenario_unsupported_alg_bad_request();
	if j != 0 { return j; }
	val k = scenario_error_envelope_unauthorized();
	if k != 0 { return k; }
	val l = scenario_typ_mismatch_bad_request();
	if l != 0 { return l; }
	val m = scenario_lowercase_authorization_header();
	if m != 0 { return m; }
	return 0;
}
