module web.rest.tests.stress.stress_test

import std.core as core;
import std.io as io;
import std.net as net;
import std.concurrent as conc;
import std.time as time;
import web.jwt as jwt;
import web.rest as rest;
import web.rest.app as rest_app;

// Stress & correctness tests for the REST server.
// Separated from unit tests: slower, timing-sensitive, exercises sustained load.

// --- Shared byte/string helpers ---

fn _to_bytes(s: &String) nothrow -> Array<Byte> {
	var out: Array<Byte> = [];
	var i = 0;
	val n = s.byte_length();
	while i < n {
		out.push(core.string_byte_at(s, i));
		i = i + 1;
	}
	return move out;
}

fn _bytes_to_string(raw: &Array<Byte>) nothrow -> String {
	val n = raw.len;
	if n == 0 {
		return "";
	}
	var b = io.buffer(n);
	var i = 0;
	while i < n {
		io.buffer_write(&mut b, i, raw[i]);
		i = i + 1;
	}
	return core.string_from_utf8_bytes(io.buffer_ptr(&b), n);
}

// --- Shared string matchers ---

fn _contains(haystack: &String, needle: &String) nothrow -> Bool {
	val h_len = haystack.byte_length();
	val n_len = needle.byte_length();
	if n_len > h_len {
		return false;
	}
	var i = 0;
	val limit = h_len - n_len + 1;
	while i < limit {
		var matched = true;
		var j = 0;
		while j < n_len {
			if core.string_byte_at(haystack, i + j) != core.string_byte_at(needle, j) {
				matched = false;
				j = n_len;
			} else {
				j = j + 1;
			}
		}
		if matched {
			return true;
		}
		i = i + 1;
	}
	return false;
}

fn _starts_with(s: &String, prefix: &String) nothrow -> Bool {
	val p_len = prefix.byte_length();
	if s.byte_length() < p_len {
		return false;
	}
	var i = 0;
	while i < p_len {
		if core.string_byte_at(s, i) != core.string_byte_at(prefix, i) {
			return false;
		}
		i = i + 1;
	}
	return true;
}

// --- Shared TCP helpers ---

fn _http_roundtrip(port: Int, raw_request: &String, timeout: conc.Duration) nothrow -> core.Result<String, Int> {
	var addr = net.socket_addr("127.0.0.1", port);
	match net.connect(&addr, timeout) {
		core.Result::Err(_) => { return core.Result::Err(1); },
		core.Result::Ok(conn) => {
			var stream = move conn;
			val req_bytes = _to_bytes(raw_request);
			var wbuf = io.buffer(req_bytes.len);
			var i = 0;
			while i < req_bytes.len {
				io.buffer_write(&mut wbuf, i, req_bytes[i]);
				i = i + 1;
			}
			match stream.write(&wbuf, timeout) {
				core.Result::Err(_) => {
					val _ = stream.close(timeout);
					return core.Result::Err(2);
				},
				core.Result::Ok(_) => {}
			}
			var collected: Array<Byte> = [];
			var done = false;
			while !done {
				var rbuf = io.buffer(4096);
				match stream.read(&mut rbuf, timeout) {
					core.Result::Err(_) => { done = true; },
					core.Result::Ok(n) => {
						if n == 0 {
							done = true;
						} else {
							var j = 0;
							while j < n {
								collected.push(io.buffer_read(&mut rbuf, j));
								j = j + 1;
							}
						}
					}
				}
			}
			val _ = stream.close(timeout);
			return core.Result::Ok(_bytes_to_string(&collected));
		}
	}
}

fn _run_serve(a: rest.App, listener: net.TcpListener, handle: rest.ServerHandle, timeout: conc.Duration) nothrow -> Int {
	match rest.serve(move a, move listener, move handle, timeout) {
		core.Result::Ok(_) => { return 0; },
		core.Result::Err(_) => { return 1; }
	}
}

// --- Multi-roundtrip lifecycle helper ---
//
// Sets up server with max_requests = requests.len, sends all requests
// sequentially, collects responses. Stops server and joins VT before
// returning.

fn _multi_roundtrip(app: rest.App, requests: &Array<String>, timeout: conc.Duration) nothrow -> core.Result<Array<String>, Int> {
	match rest.listen_app(&app, timeout) {
		core.Result::Err(_) => { return core.Result::Err(1); },
		core.Result::Ok(lst) => {
			var listener = move lst;
			val port = listener.local_port();
			var handle = rest.new_server_handle();
			handle.max_requests = requests.len;
			var caller_handle = rest.clone_handle(&handle);
			var sv = conc.spawn_cb(| | captures(move app, move listener, move handle, copy timeout) => {
				return _run_serve(move app, move listener, move handle, timeout);
			});

			var responses: Array<String> = [];
			var ok = true;
			var i = 0;
			while i < requests.len {
				if ok {
					match _http_roundtrip(port, &requests[i], timeout) {
						core.Result::Err(_) => {
							ok = false;
						},
						core.Result::Ok(resp_str) => {
							responses.push(move resp_str);
						}
					}
				}
				i = i + 1;
			}

			rest.stop(&caller_handle);
			match sv.join() {
				core.Result::Err(_) => { return core.Result::Err(2); },
				core.Result::Ok(exit_code) => {
					if exit_code != 0 { return core.Result::Err(3); }
				}
			}

			if !ok {
				return core.Result::Err(4);
			}

			return core.Result::Ok(move responses);
		}
	}
}

// --- JWT helpers ---

fn _test_secret() nothrow -> Array<Byte> {
	var out: Array<Byte> = [cast<Byte>(115), cast<Byte>(101), cast<Byte>(99), cast<Byte>(114), cast<Byte>(101), cast<Byte>(116)];
	return move out;
}

fn _build_policy() nothrow -> jwt.JwtVerifyPolicy {
	var pb = jwt.new_verify_policy_builder();
	pb.require_typ_jwt = false;
	match jwt.build_verify_policy(move pb) {
		core.Result::Ok(v) => { return v; },
		core.Result::Err(_) => {
			return jwt.JwtVerifyPolicy(skew_sec = 0, max_future_iat_sec = 0, require_typ_jwt = false);
		}
	}
}

fn _jwt_guard_owned(req: &rest.Request, c: &mut rest.Context) nothrow -> core.Result<Void, rest.RestError> {
	var config = rest.new_jwt_guard_config(_test_secret(), _build_policy());
	config.now_unix = time.utc_unix_seconds_now();
	return rest.jwt_guard_apply(&config, req, c);
}

// --- Handler helpers ---

fn _health_handler(req: &rest.Request, c: &mut rest.Context) nothrow -> core.Result<rest.Response, rest.RestError> {
	return core.Result::Ok(rest.json_response(200, "{\"ok\":true}"));
}

fn _echo_query_handler(req: &rest.Request, c: &mut rest.Context) nothrow -> core.Result<rest.Response, rest.RestError> {
	val name = "key";
	match rest.query_param(req, &name) {
		Optional::Some(v) => {
			val body = "{\"key\":\"" + v + "\"}";
			return core.Result::Ok(rest.json_response(200, body));
		},
		Optional::None => {
			return core.Result::Ok(rest.json_response(200, "{\"key\":null}"));
		}
	}
}

fn _echo_body_handler(req: &rest.Request, c: &mut rest.Context) nothrow -> core.Result<rest.Response, rest.RestError> {
	match rest.body_json(req) {
		core.Result::Ok(_) => {
			return core.Result::Ok(rest.json_response(200, "{\"echo\":true}"));
		},
		core.Result::Err(e) => {
			return core.Result::Err(e);
		}
	}
}

fn _me_handler(req: &rest.Request, c: &mut rest.Context) nothrow -> core.Result<rest.Response, rest.RestError> {
	match rest.get_principal(c) {
		Optional::Some(p) => {
			val body = "{\"sub\":\"" + p.sub + "\"}";
			return core.Result::Ok(rest.json_response(200, body));
		},
		Optional::None => {
			return core.Result::Err(rest.rest_error(401, "unauthorized", "missing-principal", "no principal"));
		}
	}
}

// --- Shared client VT helper ---

fn _client_health_check(port: Int, timeout: conc.Duration) nothrow -> Int {
	val raw_req = "GET /health HTTP/1.1\r\nHost: localhost\r\n\r\n";
	match _http_roundtrip(port, &raw_req, timeout) {
		core.Result::Err(_) => { return 1; },
		core.Result::Ok(resp_str) => {
			val s_200 = "HTTP/1.1 200 OK";
			if !_starts_with(&resp_str, &s_200) { return 2; }
			val m_health = "{\"ok\":true}";
			if !_contains(&resp_str, &m_health) { return 3; }
			return 0;
		}
	}
}

// --- Scenario 1: Many sequential requests, mixed types (100-range) ---
//
// Sends 50 requests cycling through 5 types: health, echo query, echo body,
// 404, and 401. Exercises success paths, error paths, body parsing, query
// params, and guard rejection across a sustained run.

fn scenario_many_sequential_mixed() nothrow -> Int {
	val timeout = conc.Duration(millis = 5000);

	var b = rest.new_app_builder();
	rest.bind(&mut b, "127.0.0.1", 0);
	match rest.build_app(move b) {
		core.Result::Err(_) => { return 101; },
		core.Result::Ok(a) => {
			var app = move a;

			// Ungrouped routes
			match rest_app.add_route(&mut app, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 102; },
				core.Result::Ok(_) => {}
			}
			match rest_app.add_route(&mut app, "GET", "/v1/echo", core.callback2(_echo_query_handler)) {
				core.Result::Err(_) => { return 103; },
				core.Result::Ok(_) => {}
			}
			match rest_app.add_route(&mut app, "POST", "/v1/echo", core.callback2(_echo_body_handler)) {
				core.Result::Err(_) => { return 104; },
				core.Result::Ok(_) => {}
			}

			// Guarded group for /v1/me
			match rest.add_group(&mut app, "/v1") {
				core.Result::Err(_) => { return 105; },
				core.Result::Ok(group) => {
					rest.add_group_guard(&mut app, &group, core.callback2(_jwt_guard_owned));
					match rest_app.add_group_route(&mut app, &group, "GET", "/me", core.callback2(_me_handler)) {
						core.Result::Err(_) => { return 106; },
						core.Result::Ok(_) => {}
					}
				}
			}

			// Build 50 requests: 10 cycles of 5 types
			var requests: Array<String> = [];
			var cycle = 0;
			while cycle < 10 {
				var r0 = "GET /health HTTP/1.1\r\nHost: localhost\r\n\r\n";
				requests.push(move r0);
				var r1 = "GET /v1/echo?key=stress HTTP/1.1\r\nHost: localhost\r\n\r\n";
				requests.push(move r1);
				var r2 = "POST /v1/echo HTTP/1.1\r\nHost: localhost\r\nContent-Length: 15\r\n\r\n{\"test\":\"body\"}";
				requests.push(move r2);
				var r3 = "GET /nonexistent HTTP/1.1\r\nHost: localhost\r\n\r\n";
				requests.push(move r3);
				var r4 = "GET /v1/me HTTP/1.1\r\nHost: localhost\r\n\r\n";
				requests.push(move r4);
				cycle = cycle + 1;
			}

			match _multi_roundtrip(move app, &requests, timeout) {
				core.Result::Err(_) => { return 110; },
				core.Result::Ok(responses) => {
					if responses.len != 50 { return 111; }

					val s_200 = "HTTP/1.1 200 OK";
					val s_404 = "HTTP/1.1 404 Not Found";
					val s_401 = "HTTP/1.1 401 Unauthorized";
					val m_health = "{\"ok\":true}";
					val m_key = "\"key\":\"stress\"";
					val m_echo = "\"echo\":true";
					val m_notfound = "\"event\":\"not-found\"";
					val m_unauth = "\"event\":\"unauthorized\"";

					var j = 0;
					var kind = 0;
					while j < 50 {
						if kind == 0 {
							if !_starts_with(&responses[j], &s_200) { return 120; }
							if !_contains(&responses[j], &m_health) { return 121; }
						}
						if kind == 1 {
							if !_starts_with(&responses[j], &s_200) { return 122; }
							if !_contains(&responses[j], &m_key) { return 123; }
						}
						if kind == 2 {
							if !_starts_with(&responses[j], &s_200) { return 124; }
							if !_contains(&responses[j], &m_echo) { return 125; }
						}
						if kind == 3 {
							if !_starts_with(&responses[j], &s_404) { return 126; }
							if !_contains(&responses[j], &m_notfound) { return 127; }
						}
						if kind == 4 {
							if !_starts_with(&responses[j], &s_401) { return 128; }
							if !_contains(&responses[j], &m_unauth) { return 129; }
						}
						kind = kind + 1;
						if kind >= 5 {
							kind = 0;
						}
						j = j + 1;
					}

					return 0;
				}
			}
		}
	}
}

// --- Scenario 2: Concurrent client connections (200-range) ---
//
// Spawns 10 client VTs that connect ~simultaneously. Server processes them
// one at a time from the accept loop while client VTs park on their own I/O.
// Exercises VT scheduler under contention and OS backlog draining.

fn scenario_concurrent_clients() nothrow -> Int {
	val timeout = conc.Duration(millis = 10000);

	var b = rest.new_app_builder();
	rest.bind(&mut b, "127.0.0.1", 0);
	match rest.build_app(move b) {
		core.Result::Err(_) => { return 201; },
		core.Result::Ok(a) => {
			var app = move a;
			match rest_app.add_route(&mut app, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 202; },
				core.Result::Ok(_) => {}
			}

			match rest.listen_app(&app, timeout) {
				core.Result::Err(_) => { return 203; },
				core.Result::Ok(lst) => {
					var listener = move lst;
					val port = listener.local_port();
					var handle = rest.new_server_handle();
					handle.max_requests = 10;
					var caller_handle = rest.clone_handle(&handle);

					var sv = conc.spawn_cb(| | captures(move app, move listener, move handle, copy timeout) => {
						return _run_serve(move app, move listener, move handle, timeout);
					});

					// Spawn 10 client VTs
					var c0 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c1 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c2 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c3 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c4 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c5 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c6 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c7 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c8 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });
					var c9 = conc.spawn_cb(| | captures(copy port, copy timeout) => { return _client_health_check(port, timeout); });

					// Join all 10 — join every VT even if some fail
					var join_err = 0;
					var check_err = 0;

					match c0.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c1.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c2.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c3.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c4.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c5.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c6.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c7.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c8.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }
					match c9.join() { core.Result::Err(_) => { join_err = join_err + 1; }, core.Result::Ok(code) => { if code != 0 { check_err = check_err + 1; } } }

					// Stop server and join
					rest.stop(&caller_handle);
					match sv.join() {
						core.Result::Err(_) => { return 204; },
						core.Result::Ok(exit_code) => {
							if exit_code != 0 { return 205; }
						}
					}

					if join_err > 0 { return 210; }
					if check_err > 0 { return 211; }
					return 0;
				}
			}
		}
	}
}

// --- Scenario 3: Repeated start/stop cycles (300-range) ---
//
// 5 full lifecycles: build app → listen → spawn serve → roundtrip → stop → join.
// Each cycle is a fresh server instance on port 0. Catches leaked fds,
// listener handles, or Arc refcounts across lifecycles. Memcheck pins
// leaked allocations.

fn _start_stop_cycle(timeout: conc.Duration) nothrow -> Int {
	var b = rest.new_app_builder();
	rest.bind(&mut b, "127.0.0.1", 0);
	match rest.build_app(move b) {
		core.Result::Err(_) => { return 1; },
		core.Result::Ok(a) => {
			var app = move a;
			match rest_app.add_route(&mut app, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 2; },
				core.Result::Ok(_) => {}
			}
			match rest.listen_app(&app, timeout) {
				core.Result::Err(_) => { return 3; },
				core.Result::Ok(lst) => {
					var listener = move lst;
					val port = listener.local_port();
					var handle = rest.new_server_handle();
					handle.max_requests = 1;
					var caller_handle = rest.clone_handle(&handle);
					var sv = conc.spawn_cb(| | captures(move app, move listener, move handle, copy timeout) => {
						return _run_serve(move app, move listener, move handle, timeout);
					});

					val result = _client_health_check(port, timeout);

					rest.stop(&caller_handle);
					match sv.join() {
						core.Result::Err(_) => { return 4; },
						core.Result::Ok(exit_code) => {
							if exit_code != 0 { return 5; }
						}
					}

					if result != 0 { return 6; }
					return 0;
				}
			}
		}
	}
}

fn scenario_start_stop_cycles() nothrow -> Int {
	val timeout = conc.Duration(millis = 5000);
	var i = 0;
	while i < 5 {
		val result = _start_stop_cycle(timeout);
		if result != 0 { return 300 + result; }
		i = i + 1;
	}
	return 0;
}

// --- Scenario 4: Large headers near limit (400-range) ---
//
// Two sub-cases: safely under 8192-byte MAX_HEADER_SIZE (200 OK) and
// safely over (400 header-too-large). No exact-boundary pinning.

// Build a GET /health request padded to approximately
// 41 + pad_count * 109 bytes (request line + host + N pad headers + terminator).
fn _padded_request(pad_count: Int) nothrow -> String {
	// 100-byte pad value via doubling
	var pad = "AAAAAAAAAA"; // 10
	pad = pad + pad; // 20
	pad = pad + pad; // 40
	pad = pad + pad; // 80
	pad = pad + "AAAAAAAAAAAAAAAAAAAA"; // 100

	var req = "GET /health HTTP/1.1\r\nHost: localhost\r\n"; // 39 bytes
	var i = 0;
	while i < pad_count {
		req = req + "X-Pad: " + pad + "\r\n"; // 109 bytes each
		i = i + 1;
	}
	req = req + "\r\n"; // 2 bytes
	return req;
}

fn scenario_large_headers() nothrow -> Int {
	val timeout = conc.Duration(millis = 5000);

	// Sub 1: safely under limit — 63 pad headers → ~6908 bytes total → 200 OK
	var b1 = rest.new_app_builder();
	rest.bind(&mut b1, "127.0.0.1", 0);
	match rest.build_app(move b1) {
		core.Result::Err(_) => { return 401; },
		core.Result::Ok(a1) => {
			var app1 = move a1;
			match rest_app.add_route(&mut app1, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 402; },
				core.Result::Ok(_) => {}
			}
			var reqs1: Array<String> = [];
			var r1 = _padded_request(63);
			reqs1.push(move r1);
			match _multi_roundtrip(move app1, &reqs1, timeout) {
				core.Result::Err(_) => { return 403; },
				core.Result::Ok(resps1) => {
					val s_200 = "HTTP/1.1 200 OK";
					if !_starts_with(&resps1[0], &s_200) { return 404; }
					val m_health = "{\"ok\":true}";
					if !_contains(&resps1[0], &m_health) { return 405; }
				}
			}
		}
	}

	// Sub 2: safely over limit — 92 pad headers → ~10069 bytes total → 400
	var b2 = rest.new_app_builder();
	rest.bind(&mut b2, "127.0.0.1", 0);
	match rest.build_app(move b2) {
		core.Result::Err(_) => { return 410; },
		core.Result::Ok(a2) => {
			var app2 = move a2;
			match rest_app.add_route(&mut app2, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 411; },
				core.Result::Ok(_) => {}
			}
			var reqs2: Array<String> = [];
			var r2 = _padded_request(92);
			reqs2.push(move r2);
			match _multi_roundtrip(move app2, &reqs2, timeout) {
				core.Result::Err(_) => { return 412; },
				core.Result::Ok(resps2) => {
					val s_400 = "HTTP/1.1 400 Bad Request";
					if !_starts_with(&resps2[0], &s_400) { return 413; }
					val m_tag = "header-too-large";
					if !_contains(&resps2[0], &m_tag) { return 414; }
				}
			}
		}
	}

	return 0;
}

// --- Scenario 5: Malformed request matrix (500-range) ---
//
// Sends a variety of malformed HTTP payloads and verifies proper error
// responses. Each sub-case uses a single server with max_requests = 1 to
// keep lifecycle clean. The server must stay alive and respond to every one.
//
// Tags allowed per sub-case:
//   1. empty connect-close: read-failed or empty-request
//   2. blank request line (\r\n\r\n): malformed-http
//   3. no path (GET\r\n\r\n): malformed-http
//   4. Content-Length but no body: incomplete-body
//   5. binary garbage + \r\n\r\n: malformed-http
//   6. truncated body: incomplete-body
//   7. no HTTP version (GET /health\r\n\r\n): malformed-http

// Raw send+recv: connect, optionally write raw bytes, read whatever comes back.
// If payload is empty string, connects then immediately closes write direction
// by closing the stream, but we still need to read response before that.
// For empty-connect, we connect, send nothing, and wait for server to respond
// (server sees EOF or read error).
fn _raw_send_recv(port: Int, payload: &String, timeout: conc.Duration) nothrow -> core.Result<String, Int> {
	var addr = net.socket_addr("127.0.0.1", port);
	match net.connect(&addr, timeout) {
		core.Result::Err(_) => { return core.Result::Err(1); },
		core.Result::Ok(conn) => {
			var stream = move conn;
			// Write payload if non-empty
			if payload.byte_length() > 0 {
				val req_bytes = _to_bytes(payload);
				var wbuf = io.buffer(req_bytes.len);
				var i = 0;
				while i < req_bytes.len {
					io.buffer_write(&mut wbuf, i, req_bytes[i]);
					i = i + 1;
				}
				match stream.write(&wbuf, timeout) {
					core.Result::Err(_) => {
						val _ = stream.close(timeout);
						return core.Result::Err(2);
					},
					core.Result::Ok(_) => {}
				}
			}
			// Read response
			var collected: Array<Byte> = [];
			var done = false;
			while !done {
				var rbuf = io.buffer(4096);
				match stream.read(&mut rbuf, timeout) {
					core.Result::Err(_) => { done = true; },
					core.Result::Ok(n) => {
						if n == 0 {
							done = true;
						} else {
							var j = 0;
							while j < n {
								collected.push(io.buffer_read(&mut rbuf, j));
								j = j + 1;
							}
						}
					}
				}
			}
			val _ = stream.close(timeout);
			if collected.len == 0 {
				return core.Result::Err(3);
			}
			return core.Result::Ok(_bytes_to_string(&collected));
		}
	}
}

// Run one malformed sub-case: build app, listen, serve with max_requests=1,
// send the payload, check response against expected status line and allowed tags.
// allowed_tag1 and allowed_tag2: at least one must appear in the response body.
// Pass empty string for allowed_tag2 if only one tag is acceptable.
// server_timeout: used for the server's I/O (controls how fast it times out on
//   missing body bytes).
// client_timeout: used for the client's connect/write/read (should be longer
//   than server_timeout so client outlives server's error path).
fn _malformed_subcase(payload: &String, expected_status: &String, allowed_tag1: &String, allowed_tag2: &String, server_timeout: conc.Duration, client_timeout: conc.Duration) nothrow -> Int {
	var b = rest.new_app_builder();
	rest.bind(&mut b, "127.0.0.1", 0);
	match rest.build_app(move b) {
		core.Result::Err(_) => { return 1; },
		core.Result::Ok(a) => {
			var app = move a;
			match rest_app.add_route(&mut app, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 2; },
				core.Result::Ok(_) => {}
			}
			match rest.listen_app(&app, client_timeout) {
				core.Result::Err(_) => { return 3; },
				core.Result::Ok(lst) => {
					var listener = move lst;
					val port = listener.local_port();
					var handle = rest.new_server_handle();
					handle.max_requests = 1;
					var caller_handle = rest.clone_handle(&handle);
					var sv = conc.spawn_cb(| | captures(move app, move listener, move handle, copy server_timeout) => {
						return _run_serve(move app, move listener, move handle, server_timeout);
					});

					match _raw_send_recv(port, payload, client_timeout) {
						core.Result::Err(_) => {
							rest.stop(&caller_handle);
							val _ = sv.join();
							return 4;
						},
						core.Result::Ok(resp_str) => {
							rest.stop(&caller_handle);
							match sv.join() {
								core.Result::Err(_) => { return 5; },
								core.Result::Ok(exit_code) => {
									if exit_code != 0 { return 6; }
								}
							}

							if !_starts_with(&resp_str, expected_status) { return 7; }

							// Check that at least one allowed tag appears
							val has_tag1 = _contains(&resp_str, allowed_tag1);
							if allowed_tag2.byte_length() == 0 {
								if !has_tag1 { return 8; }
							} else {
								val has_tag2 = _contains(&resp_str, allowed_tag2);
								if !has_tag1 {
									if !has_tag2 { return 8; }
								}
							}
							return 0;
						}
					}
				}
			}
		}
	}
}

fn scenario_malformed_matrix() nothrow -> Int {
	val timeout = conc.Duration(millis = 5000);
	// For truncated-body cases: server uses short timeout so it times out fast
	// on the missing body bytes, client uses longer timeout so it outlives the
	// server's error path and reads the response.
	val srv_short = conc.Duration(millis = 1000);
	val cli_long = conc.Duration(millis = 5000);
	val s_400 = "HTTP/1.1 400 Bad Request";
	val t_read_failed = "read-failed";
	val t_empty = "empty-request";
	val t_malformed = "malformed-http";
	val t_incomplete = "incomplete-body";
	val empty = "";

	// Sub 1: empty connect-close — server sees EOF/error, stays alive.
	// Client connects then immediately closes. Server gets read-failed or
	// empty-request, writes error response (may fail — client is gone), and
	// proceeds. We verify the server VT exits cleanly.
	var b1 = rest.new_app_builder();
	rest.bind(&mut b1, "127.0.0.1", 0);
	match rest.build_app(move b1) {
		core.Result::Err(_) => { return 501; },
		core.Result::Ok(a1) => {
			var app1 = move a1;
			match rest_app.add_route(&mut app1, "GET", "/health", core.callback2(_health_handler)) {
				core.Result::Err(_) => { return 502; },
				core.Result::Ok(_) => {}
			}
			match rest.listen_app(&app1, timeout) {
				core.Result::Err(_) => { return 503; },
				core.Result::Ok(lst1) => {
					var listener1 = move lst1;
					val port1 = listener1.local_port();
					var handle1 = rest.new_server_handle();
					handle1.max_requests = 1;
					var caller1 = rest.clone_handle(&handle1);
					var sv1 = conc.spawn_cb(| | captures(move app1, move listener1, move handle1, copy timeout) => {
						return _run_serve(move app1, move listener1, move handle1, timeout);
					});

					// Connect and immediately close
					var addr1 = net.socket_addr("127.0.0.1", port1);
					match net.connect(&addr1, timeout) {
						core.Result::Err(_) => {
							rest.stop(&caller1);
							val _ = sv1.join();
							return 504;
						},
						core.Result::Ok(conn1) => {
							var s1 = move conn1;
							val _ = s1.close(timeout);
						}
					}

					// Server processes the empty connection then stops
					rest.stop(&caller1);
					match sv1.join() {
						core.Result::Err(_) => { return 505; },
						core.Result::Ok(exit_code) => {
							if exit_code != 0 { return 506; }
						}
					}
				}
			}
		}
	}

	// Sub 2: blank request line (\r\n\r\n only)
	val p2 = "\r\n\r\n";
	val r2 = _malformed_subcase(&p2, &s_400, &t_malformed, &empty, timeout, timeout);
	if r2 != 0 { return 510 + r2; }

	// Sub 3: no path (GET\r\n\r\n)
	val p3 = "GET\r\n\r\n";
	val r3 = _malformed_subcase(&p3, &s_400, &t_malformed, &empty, timeout, timeout);
	if r3 != 0 { return 520 + r3; }

	// Sub 4: Content-Length declared but no body (server read times out)
	val p4 = "GET / HTTP/1.1\r\nContent-Length: 100\r\n\r\n";
	val r4 = _malformed_subcase(&p4, &s_400, &t_incomplete, &empty, srv_short, cli_long);
	if r4 != 0 { return 530 + r4; }

	// Sub 5: binary garbage + \r\n\r\n
	var p5 = "~~~~~~~~~~~~~~~~~~~~\r\n\r\n";
	val r5 = _malformed_subcase(&p5, &s_400, &t_malformed, &empty, timeout, timeout);
	if r5 != 0 { return 540 + r5; }

	// Sub 6: truncated body (Content-Length: 5, only 2 bytes sent; server read times out)
	val p6 = "POST /health HTTP/1.1\r\nContent-Length: 5\r\n\r\nAB";
	val r6 = _malformed_subcase(&p6, &s_400, &t_incomplete, &empty, srv_short, cli_long);
	if r6 != 0 { return 550 + r6; }

	// Sub 7: no HTTP version (GET /health\r\n\r\n)
	val p7 = "GET /health\r\n\r\n";
	val r7 = _malformed_subcase(&p7, &s_400, &t_malformed, &empty, timeout, timeout);
	if r7 != 0 { return 560 + r7; }

	return 0;
}

fn main() nothrow -> Int {
	val a = scenario_many_sequential_mixed();
	if a != 0 { return a; }
	val b = scenario_concurrent_clients();
	if b != 0 { return b; }
	val c = scenario_start_stop_cycles();
	if c != 0 { return c; }
	val d = scenario_large_headers();
	if d != 0 { return d; }
	val e = scenario_malformed_matrix();
	if e != 0 { return e; }
	return 0;
}
