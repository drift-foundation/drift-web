module web.rest

import std.core as core;
import std.json as json;
import std.net as net;
import std.concurrent as conc;
import web.jwt as jwt;
import web.rest.errors as errors;
import web.rest.events as events;
import web.rest.response as response;
import web.rest.context as context;
import web.rest.request as request;
import web.rest.jwt_guard as jwt_guard;
import web.rest.router as router;
import web.rest.http as http;
import web.rest.server as server;
import web.rest.app as app;

export {
	RestError,
	Response,
	Request,
	Context,
	Principal,
	JwtGuardConfig,
	AppBuilder,
	App,
	Group,
	RestBadRequest,
	RestUnauthorized,
	RestForbidden,
	RestNotFound,
	RestConflict,
	RestInternal,
	EVENT_REQUEST_INVALID,
	EVENT_UNAUTHORIZED,
	EVENT_FORBIDDEN,
	EVENT_NOT_FOUND,
	EVENT_CONFLICT,
	EVENT_INTERNAL,
	TAG_INTERNAL_ERROR,
	rest_error,
	add_field,
	json_response,
	error_envelope,
	new_context,
	new_request,
	add_query_param,
	add_header,
	header,
	set_principal,
	get_principal,
	require_principal,
	query_param,
	require_query_param,
	body_json,
	require_body_json,
	add_path_param,
	path_param,
	require_path_param,
	new_jwt_guard_config,
	jwt_guard_apply,
	new_app_builder,
	bind,
	build_app,
	add_filter,
	add_group,
	add_group_guard,
	add_throws_route,
	add_group_throws_route,
	dispatch,
	split_path,
	parse_route_pattern,
	match_route,
	extract_path_params,
	ServerHandle,
	new_server_handle,
	clone_handle,
	stop,
	listen_app,
	serve,
	parse_request,
	serialize_response
};

pub type RestError = errors.RestError;
pub type Response = response.Response;
pub type Request = request.Request;
pub type Context = context.Context;
pub type Principal = context.Principal;
pub type JwtGuardConfig = jwt_guard.JwtGuardConfig;
pub type AppBuilder = app.AppBuilder;
pub type App = app.App;
pub type Group = app.Group;

pub type RestBadRequest = events.RestBadRequest;
pub type RestUnauthorized = events.RestUnauthorized;
pub type RestForbidden = events.RestForbidden;
pub type RestNotFound = events.RestNotFound;
pub type RestConflict = events.RestConflict;
pub type RestInternal = events.RestInternal;

pub const EVENT_REQUEST_INVALID: String = "request-invalid";
pub const EVENT_UNAUTHORIZED: String = "unauthorized";
pub const EVENT_FORBIDDEN: String = "forbidden";
pub const EVENT_NOT_FOUND: String = "not-found";
pub const EVENT_CONFLICT: String = "conflict";
pub const EVENT_INTERNAL: String = "internal";
pub const TAG_INTERNAL_ERROR: String = "internal-error";

pub fn rest_error(status: Int, event: String, tag: String, message: String) nothrow -> RestError {
	return errors.rest_error(status, event, tag, message);
}

pub fn add_field(err: &mut RestError, key: String, value: String) nothrow -> Void {
	return errors.add_field(err, key, value);
}

pub fn json_response(status: Int, body: String) nothrow -> Response {
	return response.json_response(status, body);
}

pub fn error_envelope(err: &RestError, event_id: &String) nothrow -> Response {
	return response.error_envelope(err, event_id);
}

pub fn new_context() nothrow -> Context {
	return context.new_context();
}

pub fn new_request(method: String, path: String) nothrow -> Request {
	return request.new_request(method, path);
}

pub fn add_query_param(req: &mut Request, key: String, value: String) nothrow -> Void {
	return request.add_query_param(req, key, value);
}

pub fn add_header(req: &mut Request, key: String, value: String) nothrow -> Void {
	return request.add_header(req, key, value);
}

pub fn header(req: &Request, name: &String) nothrow -> Optional<String> {
	return request.header(req, name);
}

pub fn set_principal(ctx: &mut Context, sub: String) nothrow -> Void {
	return context.set_principal(ctx, sub);
}

pub fn get_principal(ctx: &Context) nothrow -> Optional<Principal> {
	return context.get_principal(ctx);
}

pub fn require_principal(ctx: &Context) nothrow -> core.Result<Principal, RestError> {
	match context.get_principal(ctx) {
		Optional::Some(p) => {
			return core.Result::Ok(p);
		},
		Optional::None => {
			return core.Result::Err(errors.rest_error(401, "unauthorized", "missing-principal", "no authenticated principal in context"));
		}
	}
}

pub fn query_param(req: &Request, name: &String) nothrow -> Optional<String> {
	return request.query_param(req, name);
}

pub fn require_query_param(req: &Request, name: &String) nothrow -> core.Result<String, RestError> {
	return request.require_query_param(req, name);
}

pub fn body_json(req: &Request) nothrow -> core.Result<json.JsonNode, RestError> {
	return request.body_json(req);
}

pub fn require_body_json(req: &Request) nothrow -> core.Result<json.JsonNode, RestError> {
	return request.require_body_json(req);
}

pub fn add_path_param(req: &mut Request, key: String, value: String) nothrow -> Void {
	return request.add_path_param(req, key, value);
}

pub fn path_param(req: &Request, name: &String) nothrow -> core.Result<String, RestError> {
	return request.path_param(req, name);
}

pub fn require_path_param(req: &Request, name: &String) nothrow -> core.Result<String, RestError> {
	return request.require_path_param(req, name);
}

pub fn new_jwt_guard_config(secret: Array<Byte>, policy: jwt.JwtVerifyPolicy) nothrow -> JwtGuardConfig {
	return jwt_guard.new_jwt_guard_config(move secret, move policy);
}

pub fn jwt_guard_apply(config: &JwtGuardConfig, req: &Request, ctx: &mut Context) nothrow -> core.Result<Void, RestError> {
	return jwt_guard.jwt_guard_apply(config, req, ctx);
}

pub fn new_app_builder() nothrow -> AppBuilder {
	return app.new_app_builder();
}

pub fn bind(b: &mut AppBuilder, host: String, port: Int) nothrow -> Void {
	return app.bind(b, host, port);
}

pub fn build_app(b: AppBuilder) nothrow -> core.Result<App, RestError> {
	return app.build_app(move b);
}

pub fn add_filter(a: &mut App, filter: core.Callback2<&Request, &mut Context, core.Result<Void, RestError>>) nothrow -> Void {
	return app.add_filter(a, move filter);
}

pub fn add_group(a: &mut App, prefix: String) nothrow -> core.Result<Group, RestError> {
	return app.add_group(a, prefix);
}

pub fn add_group_guard(a: &mut App, group: &Group, guard: core.Callback2<&Request, &mut Context, core.Result<Void, RestError>>) nothrow -> Void {
	return app.add_group_guard(a, group, move guard);
}

pub fn add_throws_route(a: &mut App, method: String, path: String, handler: core.CallbackThrow2<&Request, &mut Context, Response>) nothrow -> core.Result<Void, RestError> {
	return app.add_throws_route(a, method, path, move handler);
}

pub fn add_group_throws_route(a: &mut App, group: &Group, method: String, path: String, handler: core.CallbackThrow2<&Request, &mut Context, Response>) nothrow -> core.Result<Void, RestError> {
	return app.add_group_throws_route(a, group, method, path, move handler);
}

pub fn dispatch(a: &App, req: &mut Request, ctx: &mut Context) nothrow -> core.Result<Response, RestError> {
	return app.dispatch(a, req, ctx);
}

pub fn split_path(path: &String) nothrow -> Array<String> {
	return router.split_path(path);
}

pub fn parse_route_pattern(path: &String) nothrow -> core.Result<router.RoutePattern, RestError> {
	return router.parse_route_pattern(path);
}

pub fn match_route(pattern: &router.RoutePattern, segments: &Array<String>) nothrow -> Bool {
	return router.match_route(pattern, segments);
}

pub fn extract_path_params(pattern: &router.RoutePattern, segments: &Array<String>, req: &mut Request) nothrow -> Void {
	return router.extract_path_params(pattern, segments, req);
}

pub type ServerHandle = server.ServerHandle;

pub fn new_server_handle() nothrow -> ServerHandle {
	return server.new_server_handle();
}

pub fn clone_handle(handle: &ServerHandle) nothrow -> ServerHandle {
	return server.clone_handle(handle);
}

pub fn stop(handle: &ServerHandle) nothrow -> Void {
	return server.stop(handle);
}

pub fn listen_app(a: &App, timeout: conc.Duration) nothrow -> core.Result<net.TcpListener, RestError> {
	return server.listen_app(a, timeout);
}

pub fn serve(a: App, listener: net.TcpListener, handle: ServerHandle, timeout: conc.Duration) nothrow -> core.Result<Void, RestError> {
	return server.serve(move a, move listener, move handle, timeout);
}

pub fn parse_request(raw: &Array<Byte>) nothrow -> core.Result<Request, RestError> {
	return http.parse_request(raw);
}

pub fn serialize_response(resp: &Response) nothrow -> Array<Byte> {
	return http.serialize_response(resp);
}
